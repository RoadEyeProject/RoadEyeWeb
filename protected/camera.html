<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RoadEye</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      padding-bottom: 70px;
      background: linear-gradient(135deg, #121212, #1a1a1a);
      color: #ffffff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100dvh;
      overflow: hidden;
      position: relative;
    }

    body::before {
      content: "";
      position: absolute;
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(0, 123, 255, 0.2) 0%, transparent 70%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      filter: blur(60px);
      z-index: 0;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 20px;
      z-index: 1;
    }

    #video {
      width: 90%;
      max-width: 500px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 123, 255, 0.6), 0 0 40px rgba(0, 123, 255, 0.3);
      animation: pulse 4s infinite;
      z-index: 1;
    }

    @keyframes pulse {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(0, 123, 255, 0.6), 0 0 40px rgba(0, 123, 255, 0.3);
      }

      50% {
        box-shadow: 0 0 30px rgba(0, 123, 255, 0.8), 0 0 50px rgba(0, 123, 255, 0.4);
      }
    }

    .bottom-nav {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: #222;
      display: flex;
      justify-content: space-around;
      padding: 12px 0;
      border-top: 1px solid #444;
      z-index: 10;
    }

    .nav-item {
      color: #fff;
      text-decoration: none;
      font-size: 16px;
      font-weight: 500;
      transition: color 0.3s ease;
    }

    .nav-item:hover {
      color: #00aaff;
    }

    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 123, 255, 0.9);
      color: #fff;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      z-index: 999;
      animation: fadeInOut 3.5s ease-in-out forwards;
    }

    @keyframes fadeInOut {
      0% {
        opacity: 0;
        transform: translate(-50%, -20px);
      }

      10% {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      90% {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      100% {
        opacity: 0;
        transform: translate(-50%, -20px);
      }
    }
  </style>
</head>

<body>
  <h1>RoadEye Viewport</h1>
  <video id="video" autoplay playsinline muted></video>

  <nav class="bottom-nav">
    <a href="/camera.html" class="nav-item">ðŸ“· Camera</a>
    <a href="/stats.html" class="nav-item">ðŸ“Š Stats</a>
  </nav>

  <script>
  // ====== Tunables ======
  const SEND_SIZE = 640;          // YOLO input size
  const JPEG_QUALITY = 1.0;       // 0.0..1.0
  const TARGET_FPS = 10;          // max frames/sec to send
  const CAMERA_CONSTRAINTS = {
    video: {
      facingMode: { ideal: "environment" }, // better compatibility than exact
      width:  { ideal: 1920 },              // ask high-ish; browser may give less
      height: { ideal: 1080 }
    },
    audio: false
  };
  // =======================

  const videoElement = document.getElementById('video');
  const token = getCookie('access_token');
  const wsScheme = (location.protocol === 'https:') ? 'wss' : 'ws';
  const socket = new WebSocket(`${wsScheme}://${window.location.host}?token=${encodeURIComponent(token || '')}`);

  // Geolocation cache (updated by watchPosition)
  let lastLocation = null;
  let lastLocationTime = 0;

  socket.onopen = () => console.log('âœ… WebSocket connection opened');

  socket.onmessage = (message) => {
    try {
      const data = JSON.parse(message.data);
      if (data.event && data.timestamp) {
        showToast(`ðŸš¨ ${data.event} reported!`);
      }
    } catch (_) {
      // Ignore non-JSON messages (e.g., binary frames from server)
    }
  };

  socket.onerror = (error) => console.error('WebSocket error:', error);
  socket.onclose = () => console.log('WebSocket connection closed');

  function showToast(text) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = text;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3500);
  }

  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }

  // Start geolocation watching (no per-frame geolocation calls)
  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(
      (pos) => {
        lastLocation = {
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude,
          accuracy: pos.coords.accuracy
        };
        lastLocationTime = Date.now();
      },
      (err) => {
        console.warn('Geolocation watch error:', err.message);
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 5000 }
    );
  } else {
    console.warn('Geolocation not supported.');
  }

  // Prepare a dedicated 640x640 canvas for sending
  const sendCanvas = document.createElement('canvas');
  sendCanvas.width = SEND_SIZE;
  sendCanvas.height = SEND_SIZE;
  const sendCtx = sendCanvas.getContext('2d');

  // Helper: draw full frame into a 640x640 with letterbox padding
  function drawLetterboxed(video) {
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    if (!vw || !vh) return false;

    const scale = Math.min(SEND_SIZE / vw, SEND_SIZE / vh);
    const newW = Math.round(vw * scale);
    const newH = Math.round(vh * scale);
    const dx = Math.floor((SEND_SIZE - newW) / 2);
    const dy = Math.floor((SEND_SIZE - newH) / 2);

    // Fill background (black) for letterbox bars
    sendCtx.fillStyle = 'black';
    sendCtx.fillRect(0, 0, SEND_SIZE, SEND_SIZE);
    sendCtx.drawImage(video, 0, 0, vw, vh, dx, dy, newW, newH);
    return true;
  }

  // Throttle control
  let lastSentAt = 0;
  const frameIntervalMs = 1000 / TARGET_FPS;

  function maybeSendFrame() {
    if (document.hidden) return; // pause when tab not visible

    const now = performance.now();
    if (now - lastSentAt < frameIntervalMs) return;

    const ok = drawLetterboxed(videoElement);
    if (!ok) return;

    // Encode to base64 to keep compatibility with your current server
    // (If you later switch to binary: use sendCanvas.toBlob(blob => socket.send(blob), 'image/jpeg', JPEG_QUALITY))
    const dataUrl = sendCanvas.toDataURL('image/jpeg', JPEG_QUALITY);

    const message = {
      type: 'frame',
      timestamp: Date.now(),
      image: dataUrl,          // base64 JPEG
      token: token || null,
      location: lastLocation,  // may be null if not granted yet
      meta: {
        sendSize: SEND_SIZE,
        jpegQuality: JPEG_QUALITY
      }
    };

    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
      lastSentAt = now;
    }
  }

  // Drive the send loop using real video frames when available
  function startPumpedSending() {
    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
      const step = () => {
        maybeSendFrame();
        videoElement.requestVideoFrameCallback(step);
      };
      videoElement.requestVideoFrameCallback(step);
    } else {
      setInterval(maybeSendFrame, frameIntervalMs);
    }
  }

  // Kick off camera
  navigator.mediaDevices.getUserMedia(CAMERA_CONSTRAINTS)
    .then((stream) => {
      videoElement.srcObject = stream;

      // Log actual camera settings for debugging
      const track = stream.getVideoTracks()[0];
      console.log('ðŸŽ¥ Camera settings:', track.getSettings());
      videoElement.onloadedmetadata = () => {
        console.log('ðŸŽ¥ Source resolution:', videoElement.videoWidth, 'x', videoElement.videoHeight);
      };

      // Start send loop once metadata is ready
      videoElement.addEventListener('loadeddata', () => startPumpedSending(), { once: true });
    })
    .catch((error) => {
      console.error('Error accessing the camera:', error);
      showToast('Camera access denied or unavailable');
    });

  // Optional: pause/resume sending when tab visibility changes
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      lastSentAt = 0; // let next frame go out immediately on resume
    }
  });
</script>

</body>

</html>